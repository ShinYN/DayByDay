# IoC Container와 빈

IoC (Inversion of Control)
- Dependency Injection이라고도 한다
- 의존객체를 직접 만드는 것이 아니라, 주입 받아서 사용하는 방법

IoC 컨테이너
- 빈을 구성하고 제공한다
- BeanFactory (최상위 인터페이스)

빈
- 스프링 IoC 컨테이너가 관리하는 객체 (=IoC 컨테이너에 들어가있는 객체)
- 컨테이너로 부터 가져와서 사용한다
- @Service, @Repository 등의 애노테이션을 사용해서 POJO 객체를 빈으로 등록
- Singleton 으로 생성된다
- 라이프사이클 인터페이스
   - 빈이 생성되었을 때 다른 동작을 추가할 수 있다
   ~~~java
   @PostConstruct
   public void postConstruct() { }
   ~~~



# Application Context
Application Context
- BeanFactory를 상속
   - BeanFactory가 가지고 있는 IoC Container 기능을 가지고 있다
- 종류
   - ClassPathXmlApplicationContext (XML)
   - AnnotationConfigApplicationContext (Java)


### 빈 등록 1 - xml 을 이용한 등록
- application.xml 
   ~~~xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

      <bean id="bookService"
            class="me.ycshin.springapplicationcontext.BookService">
         <property name="bookRepository"  ref="bookRepository"/>
      </bean>

      <bean id="bookRepository"
            class="me.ycshin.springapplicationcontext.BookRepository"/>

   </beans>
   ~~~
- Application
   ~~~java
   public static void main(String[] args) {
         ApplicationContext context = new ClassPathXmlApplicationContext("application.xml");
         String[] beanDefinitionNames = context.getBeanDefinitionNames();
         System.out.println(Arrays.toString(beanDefinitionNames));

         BookService bookService = (BookService) context.getBean("bookService");
         System.out.println(bookService.bookRepository != null);
      }
   ~~~

### 빈 등록 2 - Annotation 기반 등록
- application.xml : 컴포넌트 스캔을 할 패키지를 등록
   ~~~xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

      <context:component-scan base-package="me.ycshin.springapplicationcontext"/>
   </beans>
   ~~~
- 빈을 등록할 Annotation 사용
   - component를 확장받은 Annotation을 사용
   - Service, Repository 등
   ~~~java
   @Service
   public class BookService {

      @Autowired
      BookRepository bookRepository;

      public void setBookRepository(BookRepository bookRepository) {
         this.bookRepository = bookRepository;
      }
   }
   ~~~

### 빈 등록 3 - 자바에서 Configuration을 이용해서 코드에서 의존설 설정
- ApplicationConfig.java
   ~~~java
   @Configuration
   public class ApplicationConfig {

      @Bean
      public BookRepository bookRepository() {
         return new BookRepository();
      }

      @Bean
      public BookService bookService(BookRepository bookRepository) {
         BookService bookService = new BookService();
         bookService.setBookRepository(bookRepository);
         return bookService;
      }
   }
   ~~~

- SpringapplicationcontextApplication.java
   ~~~java
      public static void main(String[] args) {
         ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);

         String[] beanDefinitionNames = context.getBeanDefinitionNames();
         System.out.println(Arrays.toString(beanDefinitionNames));

         BookService bookService = (BookService) context.getBean("bookService");
         System.out.println(bookService.bookRepository != null);
      }
   ~~~

### 빈 등록 4 - 자바에서 Component 스캔
- ApplicationConfig.java : Component 스캔을 해준다
   ~~~java
   @Configuration
   @ComponentScan(basePackageClasses = SpringapplicationcontextApplication.class)
   public class ApplicationConfig {
   }

   ~~~

- SpringapplicationcontextApplication.java
   ~~~java
      public static void main(String[] args) {
         ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);

         String[] beanDefinitionNames = context.getBeanDefinitionNames();
         System.out.println(Arrays.toString(beanDefinitionNames));

         BookService bookService = (BookService) context.getBean("bookService");
         System.out.println(bookService.bookRepository != null);
      }
   ~~~

- 빈을 등록할 Annotation 사용
   - component를 확장받은 Annotation을 사용
   - Service, Repository 등
   ~~~java
   @Service
   public class BookService {

      @Autowired
      BookRepository bookRepository;

      public void setBookRepository(BookRepository bookRepository) {
         this.bookRepository = bookRepository;
      }
   }
   ~~~


### 빈 등록 5 - 스프링부트
스프링부트에서는 프로그램에 들어가 있는 `@SpringBootApplication` 이 모든걸 해준다

이 Annotation이 Component 스캔과 Configuration을 모두 포함하고 있다. 
~~~java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
~~~