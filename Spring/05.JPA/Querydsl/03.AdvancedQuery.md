## 중금 쿼리 생성
### Projection
Projection 이란
- select 절에서 필요한 값들을 선택해서 조회하는 것

Tuple 타입 Projection
- 샘플 쿼리
   ~~~java
   List<Tuple> result = queryFactory
                .select(member.username, member.age)
                .from(member)
                .fetch();
   ~~~
- tuple은 `get` 함수로 값을 참조한다
   ~~~java
   tuple.get(member.username);
   ~~~
- tuple은 repository 내에서만 사용해야 한다

JPQL을 이용한 Projection
- dto를 new로 선언해서 사용한다. 그 과정에서 전체 패키지 명을 적어야 한다
- 샘플 코드
   ~~~java
   em.createQuery("select new study.spring.querydsl.dto.MemberDto(m.username, m.age) from Member m", MemberDto.class)
                .getResultList();
   ~~~

Dto 타입 Projection
1. 필드에 할당
   - Dto의 필드에 직접 값을 할당하는 방식
   - 샘플 코드
      ~~~java
      queryFactory
        .select(Projections.fields(MemberDto.class,
                member.username,
                member.age))
        .from(member)
        .fetch();
      ~~~
2. 세터에 할당
   - Dto의 세터에 값을 할당하는 방식
   - 세터와 기본생성자가 정의되어 있어야 한다
   - 샘플 코드
      ~~~java
      ueryFactory
        .select(Projections.bean(MemberDto.class,
                member.username,
                member.age))
        .from(member)
        .fetch();
      ~~~
3. 생성자에 할당
   - 생성자를 이용해서 값을 할당하는 방식
   - 동일한 타입의 생성자가 있어야 한다
      ~~~java
      queryFactory
        .select(Projections.constructor(MemberDto.class,
                member.username,
                member.age))
        .from(member)
        .fetch();
      ~~~
4. 필드 이름이 다른 Dto에 할당하는 방식 
   - `as`와 `ExpressionUtils`를 이용해서 대응가능하다
   - 샘플 코드
      ~~~java
      queryFactory
        .select(Projections.fields(UserDto.class,
                member.username.as("name"), // 이름이 다르면 as로 풀어준다
                ExpressionUtils.as(
                        JPAExpressions
                                .select(memberSub.age.max())
                                .from(memberSub), "age")))
        .from(member)
        .fetch();
      ~~~
5. `@QueryProjection` 사용
   - 개념
      - DTO의 생성자에 `QueryProjection` 애노테이션을 사용하면 DTO에 대해서 select절에 바로 접근이 가능하다
   - 방식
      1. 생성자에 `@QueryProjection` 애노테이션 적용
         ~~~java
         @QueryProjection
         public MemberDto(String username, int age) {
            this.username = username;
            this.age = age;
         }
         ~~~
      2. compile querydsl 실행
         - dto 클래스가 qclass로 생성
      3. query dsl 코드에서 활용
         ~~~java
         queryFactory
                .select(new QMemberDto(member.username, member.age))
                .from(member)
                .fetch();
         ~~~
   - Constructor 방식과 비교
      - Constructor는 파라미터가 잘못작성되어도 런타임에 에러 확인이 가능하다는 단점이 있다
      - QueryProjection의 경우는 dto가 querydsl에 의존하게 된다는 단점이 있다

