# 관련 문서
레퍼런스 문서: [Link](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#containerport-v1-core)


# 기본 정보
## 공통
커맨드
- Minifest 실행
   ```
   kubectl apply -f {name}
   ```
   - `--recrod`: 어떤 kubectl 로 실행했는지 기록을 남긴다
- 전체 리소스 리스트 목록보기
   ```
   kubectl api-resources
- 리소스 세부 목록 보기
   ```
   kubectl describe <resource> <name>
   예: kubectl describe pods mypod
   ```
- 오브젝트 수정
   ```
   kubectl edit <resource> <resource name>
   예: kubectl edit pods testPod
   ```

## 파드 관련
커맨드 
- 파드 조회
   ```
   // 전체 조회
   kubectl get pods

   // 노드 포함 전체 조회
   kubectl get pods -o wide

   // label 포함 조회
   kubectl get pods --show-lables
   ```
- 컨테이너 접근
   ```
   // 1개 컨테이나가 실행중일 때 
   kubectl exec -it <<pod name>> -- bash

   // 2개 이상 컨테이너가 실행 중일 때
   kubectl exec -it <<pod name>> -c {container name} -- bash
   
   ```
- 컨테이너 로그 보기
  ```
  kubectl logs -f {pod name} -c {container name}
  kubectl logs <<pod name>>
  ```
- 임시 컨테이너를 배포하고 확인
   - `kubectl run -i --rm --tty debug --image=gihyodocker/fundamental:0.1.0 --restart=Never -- bash -il`
- 파드 삭제
   ```
   kubectl delete pod <<pod name>>
   kubectl delete -f <<yaml file>>
   ```

네트워크
- 1개의 파드에 포함된 컨테이너들은 여러개의 리눅스 네임스페이스를 공유한다. 네트워크 네임스페이스도 공유하기 때문에 1개 컨테이너에서 실행한 localhost가 다른 컨테이너의 localhost에서 응답할 수 있다.


## Replicaset
기능
- 정해진 수의 동일한 포드가 항상 실행되도록 한다
- 노드 장애 등으로 포드를 사용할 수 없으면 다른 노드에서 포드를 생성한다

커맨드
- ReplicaSet 조회
   ```
   kubectl get rs
   ```
- Replica 수 변경
   ```
   // yaml 파일을 수정해서 적용하면 된다
   kubectl apply -f {name}
   ```

파드와의 연결
- RS 정의에 있는 spec.selector.matchLabels에 정의된 라벨을 통해서 포드를 검색하고 관리한다

## Deployment
개념
- ReplicaSet의 상위개념
   - ReplicaSet: 똑같은 Replica 개수를 관리 및 제어하는 리소스
   - Deployment: ReplicaSet을 관리하고 다루기 위한 정보
      - ReplicaSet도 같이 생성된다
- 애플리케이션 배포의 기본 단위
   - revision을 관리해서 롤백이나 롤링배포도 가능하게 해준다

리비전
- replicaset의 수를 변경한 것으로는 바뀌지 않는다
- 컨테이너가 수정되면 새로운 리비전과 함께 새로운 파드가 생성된다
   - 기존의 replicaset은 남아있다

커맨드
- Deployment 조회
   ```
   kubectl get deployment
   kubectl get deploy
   ```
- Deployment 삭제
   ```
   kubectl delete deployment <name>
   kubectl delete -f <manufest file>
   ```
- Pod 이미지 변경
   ```
   // 방법 1
   kubectl set image deployment <deployment name> <image> --record
   예: kubectl set image deployment my-nginx-deployment nginx=nginx:1.11 --record

   // 방법 2
   deployment yaml을 변경하고, kubectl apply -f 적용

   // 방법 3
   kubectl edit 명령어로 변경
   ```
- 리비전 확인
   ```
   kubectl rollout history deployment <name>
   
   // 조회 결과 샘플
   REVISION  CHANGE-CAUSE
   1         kubectl apply --filename=deployment-nginx.yaml --record=true
   2         kubectl set image deployment my-nginx-deployment nginx=nginx:1.11 --record=true


   // 특정 리비전 확인
   kubectl rollout history deployment {name} --revision={revision number}
   ```
- 롤백하기
   ```
   kubectl rollout undo deployement <name>
   kubectl rollout undo deployement <name> --to-revision=<version>
   ```
- 현재 적용된 revision/replicaset 확인
   ```
   kubectl describe deployment <deployment name> 
   ```

## Service
개념
- 파드에 접근하기 위한 규칙을 정의한다
- 파드의 집합에 대한 경로나 서비스 디스커버리를 제공하는 리소스

서비스 참조
1. `서비스명.네임스페이스명.svc.local`
2. `서비스명.네임스페이스명`
   - svc.local은 생략 가능하다
   - 다른 네임스페이스를 참조하는 가장 짧은 방법
3. `서비스명`
   - 같은 네임스페이스라면 네임스페이스 생략 가능

### ClusterIP
개념
- 쿠버네티스 내부에서만 포드들에 접근할 때 사용한다.
- 외부로 포드를 노출하지 않기 때문에 클러스터 내부에서만 사용되는 포드에 적합하다

생성 템플릿 
```yaml
apiVersion: v1
kind: Service
metadata: 
  name: hostnmae-svc-clusterip
spec:
  ports:
  - name: web-port
    port: 8080 # 서비스가 가지는 고유와 IP와 함께 사용할 포트
    targetPort: 80   # 대상 포트
  selector:
    app: webserver   # 같은 Label을 가진 포드의 그룹에 접근
  type: ClusterIP # ClusterIP 타입
```

서비스 접근
- `ip:port` 또는 `name:port` 로 접근 가능하다
- 외부에서는 접근 불가능하다

서비스 대상 조회
```
kubectl get endpoints
```

### NodePort
개념
- 클러스터 외부에서 접근 가능
- 모든 노드의 특정 포트를 개방해서 서비스에 접근하는 방식

생성 템플릿
```yaml
apiVersion: v1
kind: Service
metadata: 
  name: hostname-svc-nodeport
spec:
  ports:
  - name: web-port
    port: 8080
    targetPort: 80
  selector: 
    app: webserver
  type: NodePort
```

서비스 접근
- 외부: `node ip: node port` 로 접근 가능
- 내부: Cluster ip와 같은 기능으로 접속 가능
   - nodeport를 생성하면 cluster ip가 할당된다
   - 내부에서는 `cluster ip:port` 로 접근 가능하다


### LoadBalancer
특징
- 서비스 생성과 동시에 로드밸런서를 새롭게 생성해서 포드와 연결한다
- NodePort는 각 Node의 IP를 알아야했지만, 로드밸런서 타입은 클라우드 플랫폼으로부터 도메인 이름과 IP를 할당받기 때문에 조금 더 쉽게 접근 가능하다. (클라우드 플랫폼이라고 한 것은 로드밸런서 타입을 사용할 때는 GCP,AWS 환경에서 사용하는 것이 편하기 때문이다)

생성 템플릿
```yaml
apiVersion: v1
kind: Service
metadata:
  name: hostname-svc-lb
spec:
  type: LoadBalancer
  selector:
    app: webserver
  ports:
  - name: web-port
    port: 80  # 로드밸런서에 접근하기 위한 포트
    targetPort: 80
```

서비스 접근
- 생성하면 아래처럼 ClusterIP와 ExternalIP가 같이 생성된다
   ```
   NAME              TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE
   hostname-svc-lb   LoadBalancer   10.36.13.203   34.64.116.0   80:30401/TCP   4m9s
   ```
   -` 30401` 포트는 NodePort 처럼 각 노드에 오픈된 port이다
- 외부: 생성된 external ip를 이용해서 접근이 가능하다
- 내부
   1. ClusterIP를 이용해서 접근 가능
   2. NodeIP와 Port(여기서는 30401)를 이용해서도 접근 가능 (=NodePort 개념)

Annotations
- aws 기준으로는 로드밸런서는 클래식 로드 밸런서가 기본적으로 생성된다. 다른 타입의 로드밸런서로 생성하려면 `annotations` 항목에 정보를 입력해준다.
  ```yaml
  metadata:
    name: hostname-svc-lb
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
  ```
- 쿠버네티스에서 annotations는 리소스의 추가적인 정보를 나타내기 위한 키-값 쌍으로 이루어져있다. 

externalTrafficPolicy
- NodePort나 LoadBalancer에서 들어온 요청을 어떤 포드로 연결한 것인지를 결정하는 옵션
- 기본적으로는 Cluster로 설정되어 있고, Local로 변경할 수 있다
- 옵션
   - Cluster: 클러스터 내의 전체 포드를 대상으로 로드 밸런싱이 되는 것
      - 예: A 노드로 들어온 요청이 B노드의 포드에서 실행될 수 있다
      - 환경에 따라 불필요한 네트워크 홉으로ㅓ 인한 레이턴시가 발생할 수 있다
   - Local: 노드에 들어온 요청은 노드 내부의 포드에서만 밸런싱된다
      - 환경에 따라 각 포드의 로드밸런싱 비율이 맞지 않을 수 있다
- 설정
   ```yaml
   spec:
     externalTrafficPolicy: Local
   ```
### External Name
개념
- 서비스가 외부 도메인을 가리키도록 설정할 수 있다
- 내부 포드들이 서비스로 요청을 보내면, 쿠버네티스 DNS가 등록된 CNAME 레코드를 반환한다. (=service에서 external-ip로 등록된다)

생성 커맨드
```yaml
apiVersion: v1
kind: Service
metadata:
  name: external-name-svc
spec:
  type: ExternalName
  externalName: www.google.com
```


- 설정 방법
   - `spec.type` 으로 설정
- ClusterIP
   - 기본값
   - 클러스터의 내부 IP 주소에 서비스를 공개할 수 있다
- NodePort
   - 클러스터 외부에서 접근할 수 있는 서비스
   - ClusterIP의 기능을 포함하면서, 각 노드에서 서비스 포트로 접속하기 위한 글로벌 포트를 개방한다
   - 외부에서는 `localhost:port`로 접근 가능하다
- LoadBalancer
- ExternalName
   - Selector나 Port 정의없이 참조 가능하다

## Ingress
개념
- 쿠버네티스 클러스터 외부로 서비스를 공개하려면 NodePort를 노출시키면된다.<br> 그런데 NodePort는 L4 라벨까지만 다룰 수 있기 때문에 HTTP/HTTPS처럼 경로를 기반으로하는 L7 레벨의 제어는 불가능하다

## Statefulset
특징
- 오브젝트가 순차적으로 만들어진다. (racecondition 때문)


참고 문서
- https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml
- https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/cloud-generic.yaml


## 도움 커맨드
bash 접속
~~~
kubectl -it exec {pod} -- bash
~~~

loca -> pod 파일 복사
- [Link](https://dev.to/mfahlandt/copy-files-from-and-to-kubernetes-pods-and-docker-container-4lgh)