## 13-1 운영체제의 메모리 관리 방식
- 변수는 컴파일되면 메모리 주소로 변경된다. 즉, 기계어 입장에서는 변수의 이름보다는 변수의 메모리주소가 중요한 것.
   - 개발자도 메모리주소를 알고 있으면 변수의 메모리 주소를 알고 있으면 값을 변경할 수 있다

- 32비트 운영체제는 RAM을 4기가까지 사용 (2^30)
- 64비트 운영체제는 RAM을 16기가까지 사용 (2^60)

- 메모리 정렬 방식
   1. 빅 엔디언
      - 메모리의 높은 주소부터 값을 저장
      - 0x123456이면 메모리에는 0x12-0x34-0x56 순으로 저장 
      - RISC 기반 유닉스, 리눅스, JAVA
   2. 리틀 엔디언
      - 메모리의 낮은 주소부터 값을 저장
      - 0x123456이면 메모리에는 0x56-0x34-0x12 순으로 저장 
      - CISC 기반 윈도우

- 기계어, 어셈블리어
   - 기계어는 컴퓨터가 사용하는 2진 숫자로 나열된 언어
      - 예: exe 파일
   - 어셈블리어는 기계어와 형식은 비슷하면서 숫자로 배열된 명령을 영단어로 변경해서 보여주는 언어
      - 기계어에 가장 가까운 저급(Low-Level)언어
      - 성능 평가나 시스템 원리를 설명할 때 많이 사용

- 직접 주소 지정 방식
   - 메모리 주소에 직접 값을 할당하는 방식
   - C에서는 변수를 이용해서 직접 주소 지정 가능
- 간접 주소 지정 방식
   - 주소 값을 이용해서 값을 저장하는 방식

## 13-2 포인터
- 포인터 선언
   ```c
   short *ptr;
- 포인터 메모리
   - 포인터 자체는 4바이트. (64비트면 8바이트)
   - 포인터의 자료형은 참조하는 주소에 저장된 값의 자료형
- 주소값은 %p를 사용
- 포인터 사용 예시
   ```c
   short birthday; // short형 birthday 변수 선언
   short *ptr = &birthday; // 포인터 ptr을 선언하고, birthday의 주소 값을 저장
   *ptr = 1024; // ptr이 가리키는 곳에 있는 값을 1024로 변경