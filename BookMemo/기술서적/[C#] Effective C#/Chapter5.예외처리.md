## Item45. 메서드가 실패했음을 알리기 위해서 예외를 이용하라
- 메서드가 요청된 작업을 제대로 수행할 수 없는 경우 예외를 발생시켜 실패가 발생했음을 알려야 한다. 
   - 오류 코드를 이용하면 사용자가 이를 무시할 수 있다 
   - 예외(=Exception)은 클래스 타입으로 오류에 대한 추가적인 정보를 가질 수 있다
- 개발자가 try/catch 블록을 작성하지 않고도 정상적으로 메서드가 수행될 수 있는지를 확인할 수 있는 API를 제공하는 것이 좋다
    - As-Is
        ```C#
        public void DoWork(){}
    - To-Be:
       ```CSharp
       public bool TryDoWork()
       {
           if (!TestCondtions())
           {
                return false;
           }

           DoWork();
           return true;
       }
       private bool TestConditions() {}
       private void DoWork() {}

- 메서드의 이름은 메서드가 어떤 작업을 수행하는지를 명확하게 드러내도록 지어야 한다
- 예외를 발생시키는 메서드를 작성할 때는 항상 예외를 유발하는 조건을 사전에 검사할 수 있는 메서드를 함께 작성하는 것을 권한다

## Item46. 리소스 정리를 위해서 using과 try/finally를 활용하라
- 관리되지 않는 리소스를 사용하는 모든 타입은 IDisposable 인터페이스를 반드시 구현해야 한다
- Dispose()를 호출해야 하는 객체를 사용할 경우 이를 보장하기 위한 가장 간단한 방법은 using 문을 사용하는 것이다. 
   - C# 컴파일러가 using문을 만나면 try/finally 블록을 자동으로 생성해준다
- using문은 IDisposable 인터페이스를 지원하는 타입에 대해서만 사용할 수 있다
   - Object 타입의 경우 사용할 수 없는데, 이 경우 'as'를 이용하면 안전하게 코드 작성이 가능하다
      ```Csharp
      object obj = Factory.CreateResource();
      using (obj as IDisposable)
      {
          // Do dit
      }
    - 임의의 객체에 대해서 using 문을 사용할 수 있을지 확실치 않다면 위와 같이 구현하는 것이 좋다
- 메서드 내에서 IDisposable 인터페이스를 구현한 객체를 지연벽수로 사용하는 경우라면 항상 using문을 사용하기 바란다
- 중첩된 using을 사용하는 것은 IL 코드로 봤을 때는 try/finally를 2번 사용하는 것과 같다. 이 경우에는 try/finally를 사용해서 블록을 자체적으로 구현해주는 것도 좋은 방법이다
- Dispose()와 Close()
   - Dispose
      - 리소스 해제 작업
      - GC.SuppressFinalize()를 호출해서 가비지 수집기에게 이 객체에 대해서는 finalizer를 호출할 필요가 없음을 알리는 작업을 수행
   - Close
      - GC에 호출하는 작업을 하지 않는다. 
   - 두 메서드를 모두 사용할 수 있다면, Dispose()를 호출하는 것이 좋다

    
## Item 47. 사용자 지정 예외 클래스를 완벽하게 작성하라
- 예외 클래스를 개발하는 개발자는 다른 에외와는 달리 별도의 조치가 필요하다고 생각되는 경우에만 추가적으로 예외 클래스를 만드는 것이 좋다. 그렇지 않으면 쓸모없는 예외 클래스를 만드는 꼴이 될 뿐이다. 
- 다시 말하지만 서로 다른 예외 클래스를 활용하여 예외를 발생시키는 유일한 이유는 catch문을 사용하여 예외를 다루는 코드를 작성할 개발자가 그 각각을 구분하여 서로 다른 작업을 수행할 수 있도록 해주기 위함이다. 따라서 에러가 발생한 시점에 복구 가능성을 염두해 두고 추가적인 정보를 담도록 예외 클래스를 작성하는 것이 좋다. 특정 파일이나 디렉터리가 존재하지 않는 경우 응용 프로그램을 복구할 수 있는가? 부적절한 보안 권한에 대한 문제는 복구 가능한가? 네트워크 접속이 불가능한 경우는? 이처럼 다른 작업이나 복구 메커니즘으로 이어질 가능성이 있는 오류가 발생한 경우라면 새로운 예외 클래스를 만들자. 
- ThirdParty Library에서 예외를 발생시킬 때, 이 정보를 InnerClass에 전달하면 더 많은 정보를 전달할 수 있다.<br>
이러한 기법을 예외 변환(Exception Translation)이라고 하는데, 저수준의 예외에 대해서 보다 세부적인 상태 정보를 포함하는 고수준의 예외로 변경하는 작업. 
   ```c#
   try
   {
      // third party action
   }
   catch (ThirdPartyException e)
   {
      var msg = $"Problem with {e.ToString()} using library";
      throw new DoingSomeWorkException(msg, e); // 예외를 매개변수로 전달
   }
   ```


## Item 48. 강력한 예외 보증을 준수하는 것이 좋다
- 데이브 에이브람스는 예외에 대한 보증을 기본 보증(basic guarantee), 강력한 보증(strong guarantee), 예외 없음 보증(no-throw guarantee) 세가지로 구분하여 정의 했다
1. 기본 보증 (basic guarantee)
   - 특정 함수 내에 발생한 예외가 이 함수를 빠져나오더라도 어떤 리소스도 누수되지 않으며, 모든 객체의 상태가 유효한 상태를 유지함을 의마한다. 이는 예외가 발생한 메서드 내에서 finally 구문이 구현되어 있음을 의미하는 것이기도 하다. 
2. 강력한 예외 보증 (strong guarantee)
   - 기본 보증에 더하여 예외 발생 시에도 프로그램의 상태가 변경되지 않음을 추가로 보증하는 것을 의미한다. 
   - 즉, 작업이 온전히 완료되거나 혹은 응용프로그램의 상태가 그대로 유지되거나 둘 중 하나의 경우만 가능해야 하며, 그 중간은 존재하지 않음을 의미한다. 
   - LINQ는 기본적으로 강력한 예외 보증 요건을 주수한게 된다. 
   - 데이터 수정 과정
      1. 방어적인 프로그램을 위해 수정할 데이터에 대한 복사본을 마련한다. 
      2. 복사해둔 데이터를 수정한다. 수정 과정에서 예외가 발생할 수도 있다. 
      3. 수정된 복사본과 원본 데이터를 교환한다. 이 교환 작업은 예외를 일이켜서는 안된다. 
   - 복사본을 만들지 않으면 일정 수준의 성능을 발휘할 수 있지만, 개인적으로는 크기가 큰 컨테이너 객체를 복사해야 하는 경우에도 가능하면 강력한 예외 보증을 준수하도록 복사본을 이요하는 방식을 선호한다. 
3. 예외 없음 보증 (no-throw guarantee)
   - 작업이 결코 실패하지 않으며 따라서 예외가 발생하지도 않음을 보증하는 것.
   - 예시
      1. finalizer
      2. Dispose()
      3. 예외 필터의 when 절
      4. 델리게이트 대상 메서드 
         - 멀티캐스트 델리게이트의 경우 메서드 중 하나가 예외를 일으키면 다른 대상 메서드가 호출되지 않는 문제가 있다. 

## Item 49. catch 후 예외를 다시 발생시키는 것보다 예외 필터가 낫다
