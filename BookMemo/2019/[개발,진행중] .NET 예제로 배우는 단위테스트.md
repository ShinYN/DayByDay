# 1. 시작
## 1장. 단위테스트의 기본
단위 테스트에 관해 보울 때, 좋은 단위 테스트를 작성하는 법이 첫 단계여야 한다. 만약 잘 알지 못한 채 단위 테스트를 마구잡이로 작성할 것이라면 아예 단위 테스트는 사용하지 않는 편이 낫고, 그것이 관리용이성이라든지 일정과 같은 부분에서 문제를 야기하는 미래를 막는 길이다. 좋은 단위테스트가 무엇인지를 먼저 정의하고 나면 처음부터 단위 테스트에 대한 잘못된 개념을 가지고 테스트를 작성하는 일을 줄일 수 있다

단위 테스트는 다음 속성들을 '가져야 한다'
- 자동화되고 반복 실행이 가능해야 한다
- 구현하기 쉬워야 한다
- 한번 작성되면 변경되지 않아야 한다
- 누구나 실행할 수 있어야 한다
- 버튼 하나를 클릭하는 것만으로 실행할 수 있어야 한다
- 속도가 빨라야 한다


프로퍼티는 로직을 포함하지 않기 때문에 테스트할 필요가 없는 코드의 대표적인 예다. 그렇지만 주의해야 한다. 프로퍼티 안에서 무엇인가를 검사하는 부분이 있다면 그 부분을 제대로 테스트할 필요가 있다. 

## 2장. 첫 단위 테스트
NUnit
- 설치: https://nunit.org/
- Visual Studio 셋업: Nuget Package에서 아래 2개 항목 추가
   - NUnit
   - NUnit.TestAdapter
- .Net Framework 4.0에서 사용 가능

테스트 대상
- 보기에 간단해 보이는지와 상관없이, 어떻게든 로직을 포함하고 있으면 다 테스트하는 것이 좋다. 로직이 제대로 작동하지 않으면 언제 제대로 작동하지 않는지 알기 위해서다

테스트 대상 규칙
- 프로젝트: `[테스트할 프로젝트].Tests`라는 이름으로 프로젝트를 만든다
- 클래스: `[클래스이름]Tests`라는 이름의 클래스를 하나이상 만든다
- 메서드: `[메서드이름]_[테스트조건]_[기대하는동작]`라는 이름의 메서드를 하나 이상 만든다
   - 테스트 조건: 기대하는 동작을 나타내기 위한 조건
   - 기대하는 동작: 테스트 조건 하에서 테스트하려는 메서드가 무엇을 하기를 기대하는지
   - 예시
      - IsValidFileName_validFileLowerCased_ReturnsTrue
      - IsValidFileName_EmptyFileName_ThrowsException

NUnit Attribute
- [TestFixture]: Test Class를 명시
- [Test]: Test Method를 명시
- [Setup]: 테스트를 수행할 때마다 작업을 수행하는 메서드를 추가한다. 초기화 코드
- [TearDown]: 테스트를 실행 후 수행되는 메서드를 추가한다. 소멸자 코드
   - 실행 순서: Setup -> Test #1 -> TearDown -> Setup -> Test #2 -> Tear Down ...

샘플 코드
```c#
[TestFixture]   // Test Class 
public class LogAnaluzerTests
{
    private LogAnalyzer _analyzer = new LogAnalyzer();

    [SetUp] // 초기화
    public void Setup()
    {
        _analyzer = new LogAnalyzer();
    }

    [Test]  // Test Method
    [Category("Slow Tests")]    // Test Method의 Category 설정
    public void IsValidFileName_validFileLowerCased_ReturnsTrue()
    {
        // Arrange
        // Act
        bool result = _analyzer.IsValidLogFileName("whatever.slf");

        // Assert
        Assert.IsTrue(result, "파일 이름이 적절하지 않음");
    }

    [Test]
    [Category("Fast Tests")]
    public void IsValidFileName_EmptyFileName_ThrowsException()
    {
        // Act && Assert
        // 특정 Exception에 대해서 처리할 때 사용하는 코드
        Assert.That(() => _analyzer.IsValidLogFileName(string.Empty),
            Throws.TypeOf<ArgumentException>());
    }

    [TearDown]  // 소멸자
    public void TearDown()
    {
        _analyzer = null;
    }
}

```


## 3장. Stub을 이용한 의존성 분리
Stub
- 시스템 상의 외부 의존물을 대신하기 위해 쓰이는 제어 가능한 대체물
- Test Code에서는 Stub을 사용해서 테스트 용 Class를 만들어서 테스트 할 수 있다

Stub 적용 예시
- 시나리오: 테스트 대상 함수에서 특정 내부 기능에 의존하고 있음
- 해결 방법
   1. 특정 내부 기능을 별도의 Class로 분리해서 책임을 넘긴다
   2. Stub을 이용해서 대체 가능하도록 하기 위해서 분리된 Class의 기능을 대표하는 상위 Interface를 만든다
   3. 테스트 대상 Class에서 생성자에 Interface를 사용해서 의존성을 주입한다
   4. Test Code에서는 테스트 대상 Class의 Object를 만들 때, 생성자에 Stub Class를 넣어서 테스트를 한다
