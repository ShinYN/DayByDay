### 페이지 참고
이 페이지는 아래 항목을 공부하면서 배운 내용을 기록한 것이다
- [책] C#으로 배우는 적응형 코드

---

## Open/closed principle
개방/폐쇄 원칙

메이어(Bertrand Mayer)의 정의 - Object-Oriendted Software Construction, 1997
- 소프트웨어 엔터티는 확장에 대해서는 개방적이어야 하지만, 수정에 대해서는 폐쇄적이어야 한다

마틴(Robert C. Martin)의 정의
- '확장에 대한 개방'은 확장 가능한 모듈의 동작을 의미한다. 애플리케이션 변경에 대한 요구 사항이 발생하면 우리는 이런 변경 사항을 만족시킬 수 있는 새로운 동작을 추가하여 모듈을 확장할 수 있다. 다시 말하면, 모듈의 동작을 수정할 수 있어야 한다는 뜻이다. 
- '수정에 대한 폐쇄'는 모듈의 동작을 확장할 때 그 결과로 인해 모듈의 소스 혹은 바이너리 코드가 변경되어서는 안 된다는 것을 의미한다. 

## 버그 픽스
버그의 경우 현재 소스에 문제가 있는 것이기 때문에 버그를 해결하고 프로그램을 정상 동작 가능하도록 변경하는 것은 OCP 원칙의 예외 사항으로 취급해야 한다. 

## 확장점
확장점이란 코드가 변경되는 내용에 대응 가능하도록 설계된 것을 말한다. 이런 확장점의 구현은 '상속'과 '인터페이스 상속'을 통해서 확보할 수 있다. 

추상 클래스의 상속은 클라이언트와 연결되는 추상 클래스를 선언하고 서브 클래스에서 추상 클래스를 상속해서 구현하는 것이다. 이 경우 추상 클래스에서는 public 접근자를 통해서 클라이언트와 통신하고 protected 접근자를 통해서 서브 클래스와 통신한다.<br>
이러한 상속은 서브클래스가 추상 클래스의 클라이언트가 되는 개념이기 때문에 서브 클래스는 수정되어서는 안된다. 

인터페이스 상속은 클라이언트와 연결되는 인터페이스를 정의하고, 서브 클래스는 인터페이스에 의존하는 것이다. 이렇게 되면 추상 클래스를 통한 상속 보다는 유연하게 구현 가능하다. 

## 적응성을 갖추기에 충분한 수준으로만 구현
확장점을 구현할 때에는 오버엔지니어링을 조심해야 한다. 확장점을 활용한 만한 상황이 벌어지지 않는다면 추상화를 위한 리팩토링을 위해 소비한 시간은 그저 낭비일 뿐이다. 뿐만 아니라 가독성이 떨어지고, 코드가 어셈블리 여기저기에 흩어지며, 실제 구현들은 인터페이스 뒤로 숨어버리게 된다. 

수정하는 클래스가 예상 가능한 변화가 없고 기존 기능에도 변경이 없다는 결론이 내려진다면 명시적으로 기능을 구현하는 것으로도 충분하다. 

## 인터페이스를 통한 확장지원
