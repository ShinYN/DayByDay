

###속성의 종류
1. 속성: 매개변수가 없는 속성
2. 인덱서: 매개변수를 필요로 하는 속성

##속성이 필요한 이유
OOP에서 중요한 것은 데이터의 캡슐화이다. 클래스에서 정의하고 있는 값을 클래스 외부에서 사용할 때, 그 값에 접근 제한을 둠으로써 보호하는 것이다. <br>
그래서 보통은 변수를 private로 선언하고, 외부에서 참조 또는 설정이 필요할 때에는 그 값을 전달 또는 설정해 주는 메서드를 만들어서 제공한다. <br>
하지만 이렇게 되면 매번 메서드를 만들어야 하는 번거로움이 있고, 외부에서 참조할 때 그 메서드를 찾아야하는 어려움도 있다. <br>

이러한 점을 속성(Property)를 이용해서 해결할 수 있다. <br>

중요한 것은 속성을 정의하여 코드를 작성하더라도 컴파일 시점에서 컴파일러는 Get, Set에 대응되는 메서드를 내부적으로 생성하여 호출한다. <br>

###자동 구현 속성
자동 구현 속성(Automatically Implemented Property, AIP)은 사용자가 별도의 변수선언 없이 get;set;만드로 속성을 만들 수 있도록 지원해 준다. <br>
>public string MyProperty{get;set;} <br>

이렇게 하면 코딩의 양이 줄어드는 장점이 있지만, 단점도 있다. 
1. 초기화를 놓칠 수 있다.
    - 생성자에서 초기화를 해 주거나
    - 속성을 선언할 때 아래와 같이 초기화 값을 설정해 주어야 한다. 
        >public string MyProperty{get;set;} = "ShinYN"; 
2. Serialize 문제
    - 자동 구현 속성의 경우 컴파일러가 필드의 이름을 임의로 정하기 때문에, 타입을 Serialize하면 복원할 수가 없다. 
    - __체크해 보자. 난 사용했으니까__
3. 버그 추적이 어렵다
    - 디버깅을 걸 수가 없기 때문이다. 
4. 항상 Get과 Set을 함께 선언해야 한다. 

##속성에서 중요한 것
1. 속성은 결국에 메서드이다. 필드가 아니라는 것을 알아야 한다. 
2. 속성은 예외를 발생시킬 수 있지만, 메서드를 그렇지 않다. 
3. 속성은 메스드에 out이나 ref매개변수로 전달할 수 없다. 
4. 속성을 한줄에서 여러번 호출하면 서로 다른 값을 반환한다. 필드는 그렇지 않다. 
    - System.DateTime.Now
5. 속성은 실행하는데 필드보다 오래 걸린다. 필드는 항상 빠르다. 

